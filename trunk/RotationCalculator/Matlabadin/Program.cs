using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using System.Diagnostics;

namespace Matlabadin
{
    public class Program
    {
		public const double BaseMeleeHit = 1.0 - 0.075 - 0.075 - 0.075;
		public const double BaseRangeHit = 1.0 - 0.075;
        public static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                ParallelProcess(Console.In);
            }
            else if (args.Length == 1)
            {
                using (TextReader tr = new StreamReader(args[0]))
                {
                    ParallelProcess(tr);
                }
            }
            else
            {
                ProcessParams(args);
            }
        }
        private static void ParallelProcess(TextReader input)
        {
            List<Task> taskList = new List<Task>();
            // Optimisation: order tasks to take advantage of graph reuse based on Task.Factory.Scheduler.MaximumConcurrencyLevel
            foreach (string[] inputArgs in GetInputs(input))
            {
                string[] args = inputArgs;
                taskList.Add(Task.Factory.StartNew(() => ProcessParams(args), TaskCreationOptions.PreferFairness));
            }
            Task.WaitAll(taskList.ToArray());
        }
        private static IEnumerable<string[]> GetInputs(TextReader input)
        {
            // Parse each input line into parameters
            string line;
            int lineNumber = 0;
            while (true)
            {
                line = input.ReadLine();
                lineNumber++;
                if (String.IsNullOrEmpty(line)) break;
                yield return line.Split(' ', '\t');
            }
        }
        private static void ProcessParams(string[] args)
        {
            if (args.Length < 5) Usage();
            string rotation;
            int stepsPerGcd;
            double mehit, rhit;
            rotation = args[0];
            if (!Int32.TryParse(args[1], out stepsPerGcd)) Usage();
            if (!Double.TryParse(args[2], out mehit)) Usage();
            if (!Double.TryParse(args[3], out rhit)) Usage();
            string file = args.Length >= 4 ? args[4] : null;
            ProcessGraph(file, rotation, stepsPerGcd, mehit, rhit);
        }
        private static DateTime BuildTime = new FileInfo(typeof(Program).Assembly.Location).CreationTime;
        private static void ProcessGraph(string file, string rotation, int stepsPerGcd, double mehit, double rhit)
        {
            if (file == null)
            {
                ProcessGraph(Console.Out, rotation, stepsPerGcd, mehit, rhit);
            }
            else
            {
                FileInfo fi = new FileInfo(file);
                if (fi.Exists && fi.Length == 0)
                {
                    Console.Error.WriteLine("Deleting empty file {0}", file);
                }
                if (fi.Exists)
                {
                    if (fi.CreationTime < BuildTime)
                    {
                        Console.Error.WriteLine("Output file {0} already exists: skipping", file);
                        return;
                    }
                    else
                    {
                        Console.Error.WriteLine("Deleting file {0} as it was generated by a previous build.", file);
                    }
                }
                if (!fi.Directory.Exists)
                {
                    fi.Directory.Create();
                }
                using (StringWriter sw = new StringWriter())
                {
                    ProcessGraph(sw, rotation, stepsPerGcd, mehit, rhit);
                    File.WriteAllText(file, sw.ToString());
                }
            }
        }
        private static void ProcessGraph(TextWriter stream, string rotation, int stepsPerGcd, double mehit, double rhit)
        {
            if (mehit < BaseMeleeHit) Console.Error.WriteLine("Warning: {0} melee hit would require negative hit rating", mehit);
            if (rhit < BaseRangeHit) Console.Error.WriteLine("Warning: {0} range hit would require negative hit rating", rhit);
            if (mehit > 1) { Console.Error.WriteLine("Warning: invalid melee hit {0}", mehit); Usage(); }
            if (rhit > 1) { Console.Error.WriteLine("Warning: invalid range hit {0}", rhit); Usage(); }
            if (stepsPerGcd != 1 && stepsPerGcd != 3 && stepsPerGcd != 5) Console.Error.WriteLine("Warning: {0} steps per GCD is untested", stepsPerGcd);
            RotationPriorityQueue<ulong> queue = new RotationPriorityQueue<ulong>(rotation);
            Int64GraphParameters gp = new Int64GraphParameters(queue, stepsPerGcd, mehit, rhit);
            Stopwatch generateGraphStopWatch = new Stopwatch();
            generateGraphStopWatch.Start();
            double[] hintPr;
            MatlabadinGraph<ulong> graph = GenerateGraph(gp, rotation, out hintPr);
            generateGraphStopWatch.Stop();
            Stopwatch convergeStopWatch = new Stopwatch();
            convergeStopWatch.Start();
            int iterationsPerformed;
            double relTolerance, absTolerance;
            double[] pr = graph.ConvergeStateProbability(
                out iterationsPerformed,
                out relTolerance,
                out absTolerance,
                initialState: hintPr);
            convergeStopWatch.Stop();
            CacheGraph(graph, pr);
            Stopwatch aggregateStopWatch = new Stopwatch();
            aggregateStopWatch.Start();
            ActionSummary result = graph.CalculateResults(pr);
            aggregateStopWatch.Stop();
            foreach (var key in result.Action.Keys.OrderBy(k => k))
            {
                stream.WriteLine("{0},{1}", key, result.Action[key]);
            }
            stream.WriteLine("Uptime_SacredShield,{0}", result.BuffUptime[(int)Buff.SS]);
            stream.WriteLine("Uptime_EternalFlame,{0}", result.BuffUptime[(int)Buff.EF]);
            stream.WriteLine("Uptime_WeakenedBlows,{0}", result.BuffUptime[(int)Buff.WB]);
            stream.WriteLine("Uptime_SotRShieldBlock,{0}", result.BuffUptime[(int)Buff.SotRSB]);
            stream.WriteLine("Stats_StateSize_Total,{0}", graph.Size);
            stream.WriteLine("Stats_StateSize_NonZero,{0}", pr.Count(p => p > 0));
            stream.WriteLine("Stats_Iterations,{0}", iterationsPerformed);
            stream.WriteLine("Stats_ReusedExistingGraph,{0}", hintPr != null ? 1 : 0);
            stream.WriteLine("Stats_Tolerance_Relative,{0}", relTolerance);
            stream.WriteLine("Stats_Tolerance_Absolute,{0}", absTolerance);
            stream.WriteLine("Stats_Time_GenerateGraph,{0}", generateGraphStopWatch.ElapsedMilliseconds);
            stream.WriteLine("Stats_Time_Converge,{0}", convergeStopWatch.ElapsedMilliseconds);
            stream.WriteLine("Stats_Time_Aggregate,{0}", aggregateStopWatch.ElapsedMilliseconds);
            stream.WriteLine("Param_Rotation,{0}", rotation);
            stream.WriteLine("Param_Hit_Melee,{0}", mehit);
            stream.WriteLine("Param_Hit_Ranged,{0}", rhit);
        }
        private static void CacheGraph(MatlabadinGraph<ulong> mg, double[] pr)
        {
            string rotation = mg.GraphParameters.Rotation.PriorityQueue;
            lock (existingGraphs)
            {
                if (!existingGraphs.ContainsKey(rotation))
                {
                    existingGraphs[rotation] = new List<Tuple<MatlabadinGraph<ulong>, double[]>>();
                }
                existingGraphs[rotation].Add(new Tuple<MatlabadinGraph<ulong>, double[]>(mg, pr));
            }
        }
        private static MatlabadinGraph<ulong> GenerateGraph(Int64GraphParameters gp, string rotation, out double[] hintPr)
        {
            // If we have previously generated a graph for the rotation, we can reuse that one and we only need to recalculate
            // the state probabilities due to differing hit/expertise.
            Tuple<MatlabadinGraph<ulong>, double[]> closestMatch = null;
            lock (existingGraphs)
            {
                if (existingGraphs.ContainsKey(rotation))
                {
                    // use the graph with the closest euclidian distance in hit/expertise space since that should have
                    // state probabilities closest to ours.
                    closestMatch = existingGraphs[rotation]
                        .Where(mg => mg.Item1.GraphParameters.HasSameShape(gp))
                        .OrderBy(mg => (mg.Item1.GraphParameters.MeleeHit - gp.MeleeHit) * (mg.Item1.GraphParameters.MeleeHit - gp.MeleeHit)
                            + (mg.Item1.GraphParameters.RangeHit - gp.RangeHit) * (mg.Item1.GraphParameters.RangeHit - gp.RangeHit))
                        .FirstOrDefault();
                }
            }
            if (closestMatch != null)
            {
                hintPr = closestMatch.Item2;
                return new MatlabadinGraph<ulong>(closestMatch.Item1, gp);
            }
            hintPr = null;
            return new MatlabadinGraph<ulong>(gp, gp);
        }
        private static Dictionary<string, List<Tuple<MatlabadinGraph<ulong>, double[]>>> existingGraphs = new Dictionary<string, List<Tuple<MatlabadinGraph<ulong>, double[]>>>();
        public static void Usage()
        {
            string message = "Matlabadin.exe <rotation> <stepsPerGcd> <mehit> <rhit> [<outputfile>]" + Environment.NewLine
                + "Input parameters can also be read from the command line using the same argument format as above";
            Console.WriteLine(message);
            Console.Error.WriteLine(message);
            Environment.Exit(1);
        }
    }
}